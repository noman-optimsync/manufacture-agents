import { InstrumentClass } from '../chunk-BLUDYAPI.js';
import { MastraError } from '../chunk-PZUZNPFM.js';
import { MastraBase } from '../chunk-VQASQG5D.js';
import { __decoratorStart, __decorateElement, __runInitializers } from '../chunk-3HXBPDKN.js';

// src/server/auth.ts
var _MastraAuthProvider_decorators, _init, _a;
_MastraAuthProvider_decorators = [InstrumentClass({
  prefix: "auth",
  excludeMethods: ["__setTools", "__setLogger", "__setTelemetry", "#log"]
})];
var MastraAuthProvider = class extends (_a = MastraBase) {
  protected;
  public;
  constructor(options) {
    super({
      component: "AUTH",
      name: options?.name
    });
    if (options?.authorizeUser) {
      this.authorizeUser = options.authorizeUser.bind(this);
    }
    this.protected = options?.protected;
    this.public = options?.public;
  }
  registerOptions(opts) {
    if (opts?.authorizeUser) {
      this.authorizeUser = opts.authorizeUser.bind(this);
    }
    if (opts?.protected) {
      this.protected = opts.protected;
    }
    if (opts?.public) {
      this.public = opts.public;
    }
  }
};
MastraAuthProvider = /*@__PURE__*/(_ => {
  _init = __decoratorStart(_a);
  MastraAuthProvider = __decorateElement(_init, 0, "MastraAuthProvider", _MastraAuthProvider_decorators, MastraAuthProvider);
  __runInitializers(_init, 1, MastraAuthProvider);

  // src/server/composite-auth.ts
  return MastraAuthProvider;
})();
// src/server/composite-auth.ts
var CompositeAuth = class extends MastraAuthProvider {
  providers;
  constructor(providers) {
    super();
    this.providers = providers;
  }
  async authenticateToken(token, request) {
    for (const provider of this.providers) {
      try {
        const user = await provider.authenticateToken(token, request);
        if (user) {
          return user;
        }
      } catch {}
    }
    return null;
  }
  async authorizeUser(user, request) {
    for (const provider of this.providers) {
      const authorized = await provider.authorizeUser(user, request);
      if (authorized) {
        return true;
      }
    }
    return false;
  }
};

// src/server/simple-auth.ts
var SimpleAuth = class extends MastraAuthProvider {
  tokens;
  headerNames;
  authenticatedUsers;
  constructor(options) {
    super(options);
    this.tokens = options.tokens;
    this.headerNames = this.normalizeHeaders(options.headers);
    this.authenticatedUsers = new Set(Object.values(this.tokens));
  }
  normalizeHeaders(headers) {
    if (!headers) {
      return ["Authorization"];
    }
    return Array.isArray(headers) ? headers : [headers];
  }
  extractBearerToken(value) {
    if (value.startsWith("Bearer ")) {
      return value.slice(7);
    }
    return value;
  }
  findTokenInHeaders(request) {
    for (const headerName of this.headerNames) {
      const headerValue = request.header(headerName);
      if (headerValue) {
        if (headerName.toLowerCase() === "authorization") {
          return this.extractBearerToken(headerValue);
        }
        return headerValue;
      }
    }
    return null;
  }
  async authenticateToken(token, request) {
    const directToken = this.extractBearerToken(token);
    if (directToken in this.tokens) {
      return this.tokens[directToken];
    }
    const headerToken = this.findTokenInHeaders(request);
    if (headerToken && headerToken in this.tokens) {
      return this.tokens[headerToken];
    }
    return null;
  }
  async authorizeUser(user, _request) {
    return this.authenticatedUsers.has(user);
  }
};

// src/server/index.ts
function validateOptions(path, options) {
  const opts = options;
  if (opts.method === void 0) {
    throw new MastraError({
      id: "MASTRA_SERVER_API_INVALID_ROUTE_OPTIONS",
      text: `Invalid options for route "${path}", missing "method" property`,
      domain: "MASTRA_SERVER" /* MASTRA_SERVER */,
      category: "USER" /* USER */
    });
  }
  if (opts.handler === void 0 && opts.createHandler === void 0) {
    throw new MastraError({
      id: "MASTRA_SERVER_API_INVALID_ROUTE_OPTIONS",
      text: `Invalid options for route "${path}", you must define a "handler" or "createHandler" property`,
      domain: "MASTRA_SERVER" /* MASTRA_SERVER */,
      category: "USER" /* USER */
    });
  }
  if (opts.handler !== void 0 && opts.createHandler !== void 0) {
    throw new MastraError({
      id: "MASTRA_SERVER_API_INVALID_ROUTE_OPTIONS",
      text: `Invalid options for route "${path}", you can only define one of the following properties: "handler" or "createHandler"`,
      domain: "MASTRA_SERVER" /* MASTRA_SERVER */,
      category: "USER" /* USER */
    });
  }
}
function registerApiRoute(path, options) {
  if (path.startsWith("/api/")) {
    throw new MastraError({
      id: "MASTRA_SERVER_API_PATH_RESERVED",
      text: `Path must not start with "/api", it's reserved for internal API routes`,
      domain: "MASTRA_SERVER" /* MASTRA_SERVER */,
      category: "USER" /* USER */
    });
  }
  validateOptions(path, options);
  return {
    path,
    method: options.method,
    handler: options.handler,
    createHandler: options.createHandler,
    openapi: options.openapi,
    middleware: options.middleware,
    requiresAuth: options.requiresAuth
  };
}
function defineAuth(config) {
  return config;
}

export { CompositeAuth, MastraAuthProvider, SimpleAuth, defineAuth, registerApiRoute };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map